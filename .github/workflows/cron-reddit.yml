name: ETL - Reddit Torino (latest 20)

on:
  schedule:
    - cron: "13 */3 * * *"   # هر 3 ساعت (UTC)؛ دقیقه 13 برای دوری از ترافیک
  workflow_dispatch: {}

jobs:
  reddit:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    concurrency:
      group: etl-reddit
      cancel-in-progress: true

    steps:
      - uses: actions/checkout@v4

      - name: Use Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Log schedule timing
        run: |
          echo "event_name=${{ github.event_name }}"
          echo "run_started_at=${{ github.run_started_at }}"
          date -u "+now_utc=%Y-%m-%dT%H:%M:%SZ"

      - name: Sanity - required secrets
        run: |
          test -n "${{ secrets.POSTGREST_URL }}" || (echo "POSTGREST_URL secret missing" && exit 1)
          test -n "${{ secrets.SERVICE_KEY }}"   || (echo "SERVICE_KEY secret missing" && exit 1)


      - name: Fetch & Upsert r/torino latest 20
        env:
          POSTGREST_URL:        ${{ secrets.POSTGREST_URL }}
          SERVICE_KEY:          ${{ secrets.SERVICE_KEY }}
          REDDIT_CLIENT_ID:     ${{ secrets.REDDIT_CLIENT_ID }}
          REDDIT_CLIENT_SECRET: ${{ secrets.REDDIT_CLIENT_SECRET }}
        run: |
          node - <<'NODE'
          // Node 20 → global fetch
          const env = {
            POSTGREST_URL: process.env.POSTGREST_URL,
            SERVICE_KEY:   process.env.SERVICE_KEY,
            CID:           process.env.REDDIT_CLIENT_ID,
            CSECRET:       process.env.REDDIT_CLIENT_SECRET,
          };
          const UA = "TOP-turin-open-data-platform/1.0 (+https://github.com/<user>/<repo>; contact: you@example.com)";

          async function getToken() {
            const basic = Buffer.from(`${env.CID}:${env.CSECRET}`).toString("base64");
            const r = await fetch("https://www.reddit.com/api/v1/access_token", {
              method: "POST",
              headers: {
                "Authorization": `Basic ${basic}`,
                "User-Agent": UA,
                "Content-Type": "application/x-www-form-urlencoded"
              },
              body: new URLSearchParams({ grant_type: "client_credentials" })
            });
            if (!r.ok) throw new Error(`oauth token ${r.status}: ${await r.text()}`);
            const j = await r.json();
            if (!j.access_token) throw new Error("no access_token");
            return j.access_token;
          }

          const clean = s => (s||"").replace(/\s+/g," ").trim();
          const trunc = (s,n=100) => s.length<=n ? s : s.slice(0,n);

          (async () => {
            const token = await getToken();

            // حتماً از oauth.reddit.com استفاده کن
            const res = await fetch("https://oauth.reddit.com/r/torino/new?limit=20&raw_json=1", {
              headers: { "Authorization": `Bearer ${token}`, "User-Agent": UA, "Accept": "application/json" }
            });
            if (!res.ok) throw new Error(`Reddit fetch ${res.status}: ${await res.text()}`);

            const j = await res.json();
            const items = Array.isArray(j?.data?.children) ? j.data.children : [];

            const rows = items.map(c => {
              const d = c.data || {};
              const text = clean(d.selftext || d.title || "");
              return {
                post_id: String(d.id||""),
                ts: new Date((d.created_utc||0)*1000).toISOString(),
                text_snippet: trunc(text, 100),
                permalink: d.permalink ? `https://www.reddit.com${d.permalink}` : null
              };
            }).filter(r => r.post_id && r.text_snippet);

            if (!rows.length) { console.log("No rows to insert."); return; }

            const ins = await fetch(`${env.POSTGREST_URL}/reddit_torino_posts`, {
              method: "POST",
              headers: {
                apikey: env.SERVICE_KEY,
                Authorization: `Bearer ${env.SERVICE_KEY}`,
                "Content-Type": "application/json",
                "Content-Profile": "api",
                Prefer: "resolution=ignore-duplicates"
              },
              body: JSON.stringify(rows)
            });
            const body = await ins.text();
            console.log(`PostgREST upsert: ${ins.status}; sent=${rows.length}; resp:`, body || "<no-body>");
            if (!ins.ok) process.exit(1);
          })().catch(e => { console.error(e); process.exit(1); });
          NODE
