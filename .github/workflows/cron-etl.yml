name: ETL - Current Weather + Air Quality + Traffic Flow (TOP)

on:
  schedule:
    - cron: "7 * * * *"   # Ÿáÿ± 1 ÿ≥ÿßÿπÿ™ (UTC) - ÿØŸÇ€åŸÇŸá 07 ÿ®ÿ±ÿß€å ÿØŸàÿ±€å ÿßÿ≤ ÿ™ÿ±ÿßŸÅ€å⁄©
  workflow_dispatch: {}    # ÿßÿ¨ÿ±ÿß€å ÿØÿ≥ÿ™€å

jobs:
  etl_now:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    concurrency:
      group: etl-now
      cancel-in-progress: true

    steps:
      - uses: actions/checkout@v4

      - name: Use Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Log schedule timing
        run: |
          echo "event_name=${{ github.event_name }}"
          echo "run_started_at=${{ github.run_started_at }}"   # ÿ≤ŸÖÿßŸÜ ÿ¥ÿ±Ÿàÿπ ÿ®Ÿá‚ÄåŸÜÿ∏ÿ± GitHub
          date -u "+now_utc=%Y-%m-%dT%H:%M:%SZ"                # ÿ≤ŸÖÿßŸÜ ŸÑÿ≠ÿ∏Ÿá‚Äåÿß€å Runner

      - name: Sanity - required secrets
        run: |
          test -n "${{ secrets.POSTGREST_URL }}" || (echo "POSTGREST_URL secret missing" && exit 1)
          test -n "${{ secrets.SERVICE_KEY }}"   || (echo "SERVICE_KEY secret missing" && exit 1)
          test -n "${{ secrets.WAQI_TOKEN }}"    || (echo "WAQI_TOKEN secret missing" && exit 1)

      - name: Fetch current weather (Open-Meteo) ‚Üí upsert api.weather_current
        env:
          POSTGREST_URL: ${{ secrets.POSTGREST_URL }}
          SERVICE_KEY:   ${{ secrets.SERVICE_KEY }}
          CITY:          Turin
          CITY_LAT:      "45.0705"
          CITY_LON:      "7.6868"
        run: |
          node - <<'NODE'
          // Node 20 ‚Üí global fetch
          const env = {
            POSTGREST_URL: process.env.POSTGREST_URL,
            SERVICE_KEY: process.env.SERVICE_KEY,
            CITY: process.env.CITY || 'Turin',
            LAT: parseFloat(process.env.CITY_LAT || '45.0705'),
            LON: parseFloat(process.env.CITY_LON || '7.6868'),
          };

          const openMeteoURL =
            `https://api.open-meteo.com/v1/forecast?latitude=${env.LAT}&longitude=${env.LON}` +
            `&current=temperature_2m,relative_humidity_2m,apparent_temperature,is_day,` +
            `wind_speed_10m,wind_direction_10m,precipitation,rain,showers,snowfall,weather_code,cloud_cover` +
            `&forecast_days=1&timezone=UTC`;

          const headers = {
            apikey: env.SERVICE_KEY,
            Authorization: `Bearer ${env.SERVICE_KEY}`,
            "Content-Type": "application/json",
            Prefer: "resolution=merge-duplicates",
            "Content-Profile": "api" // ŸÜŸàÿ¥ÿ™ŸÜ ÿØÿ± ÿßÿ≥⁄©€åŸÖÿß api
          };

          (async () => {
            const r = await fetch(openMeteoURL);
            if (!r.ok) { console.error('Open-Meteo failed', r.status, await r.text()); process.exit(1); }
            const j = await r.json();
            const c = j.current || {};

            const toMS = kph => kph==null ? null : Number(kph)/3.6;
            const num  = x   => { const n = Number(x); return Number.isFinite(n) ? n : null; };

            const row = {
              city: env.CITY,
              ts: new Date().toISOString(),
              lat: env.LAT,
              lon: env.LON,

              temperature_c:        num(c.temperature_2m),
              relative_humidity:    num(c.relative_humidity_2m),
              apparent_temperature: num(c.apparent_temperature),
              is_day:               c.is_day === 1 || c.is_day === true,

              wind_speed_ms:        toMS(num(c.wind_speed_10m)),
              wind_dir_deg:         num(c.wind_direction_10m),

              precipitation_mm:     num(c.precipitation),
              rain_mm:              num(c.rain),
              showers_mm:           num(c.showers),
              snowfall_mm:          num(c.snowfall),

              weather_code:         c.weather_code != null ? Number(c.weather_code) : null,
              cloud_cover:          num(c.cloud_cover),
            };

            const res = await fetch(`${env.POSTGREST_URL}/weather_current`, {
              method: 'POST', headers, body: JSON.stringify([row])
            });
            const body = await res.text();
            console.log('weather_current:', res.status, 'payload_len: 1', 'resp:', body || '<no-body>');
            if (!res.ok) process.exit(1);
          })().catch(e => { console.error(e); process.exit(1); });
          NODE

      




      - name: Fetch AQ (WAQI Lingotto @9360) ‚Üí upsert api.air_quality_current
        env:
          POSTGREST_URL: ${{ secrets.POSTGREST_URL }}
          SERVICE_KEY:   ${{ secrets.SERVICE_KEY }}
          WAQI_TOKEN:    ${{ secrets.WAQI_TOKEN }}
        run: |
          node - <<'NODE'
          const POSTGREST_URL = process.env.POSTGREST_URL;
          const SERVICE_KEY   = process.env.SERVICE_KEY;
          const TOKEN         = process.env.WAQI_TOKEN;

          const headers = {
            apikey: SERVICE_KEY,
            Authorization: `Bearer ${SERVICE_KEY}`,
            "Content-Type": "application/json",
            Prefer: "resolution=merge-duplicates,return=representation",
            "Content-Profile": "api"
          };

          const LAT = 45.0705, LON = 7.6868;
          const MAX_LAG_MIN = 120;

          const urlPrimary  = `https://api.waqi.info/feed/@9360/?token=${TOKEN}`;
          const urlFallback = `https://api.waqi.info/feed/geo:${LAT};${LON}/?token=${TOKEN}`;

          const num  = x => (Number.isFinite(Number(x)) ? Number(x) : null);
          const toMS = kph => (kph==null ? null : Number(kph)/3.6);

          async function fetchFeed(url, label) {
            const r = await fetch(url, { headers: { "Cache-Control": "no-cache" } });
            if (!r.ok) throw new Error(`${label} failed ${r.status} ${await r.text()}`);
            const j = await r.json();
            if (j.status !== 'ok') throw new Error(`${label} status!=ok ${JSON.stringify(j)}`);
            const d = j.data || {};
            const ts = d.time?.iso ? new Date(d.time.iso) : null;
            const lag = ts ? Math.round((Date.now() - ts.getTime())/60000) : null;
            console.log(`${label} ‚Üí station:`, d.city?.name, 'idx:', d.idx, 'iso:', d.time?.iso, 'lag_min:', lag);
            return { d, ts, lag, label };
          }

          (async () => {
            const p = await fetchFeed(urlPrimary, 'WAQI @9360');

            let chosen = p; // Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂: primary
            if (!p.ts || p.lag > MAX_LAG_MIN) {
              console.warn('Primary stale/absent ‚Üí checking geo fallback‚Ä¶');
              try {
                const g = await fetchFeed(urlFallback, 'WAQI geo');
                // ŸÅŸÇÿ∑ ÿß⁄Øÿ± fallback ÿ¨ÿØ€åÿØÿ™ÿ± ÿßÿ≤ primary ÿßÿ≥ÿ™ ÿ¨ÿß€å⁄Øÿ≤€åŸÜ ⁄©ŸÜ
                if (g.ts && (!p.ts || g.ts > p.ts)) {
                  chosen = g;
                  console.log('Picked:', g.label);
                } else {
                  console.log('Picked: primary (fallback not newer)');
                }
              } catch (e) {
                console.warn('Fallback fetch failed:', e.message);
                console.log('Picked: primary (fallback unavailable)');
              }
            } else {
              console.log('Picked: primary (fresh enough)');
            }

            const d = chosen.d;
            const iaqi = d.iaqi || {};
            const row = {
              station_id: String(d.idx ?? '9360'),
              station_name: d.city?.name || "Lingotto, Torino",
              city: "Turin",
              ts: d.time?.iso ? new Date(d.time.iso).toISOString() : new Date().toISOString(),
              lat: d.city?.geo?.[0],
              lon: d.city?.geo?.[1],

              aqi: d.aqi != null ? Number(d.aqi) : null,
              dominent_pol: d.dominentpol || null,

              co:   num(iaqi.co?.v),
              no2:  num(iaqi.no2?.v),
              o3:   num(iaqi.o3?.v),
              so2:  num(iaqi.so2?.v),
              pm10: num(iaqi.pm10?.v),
              pm25: num(iaqi.pm25?.v),

              temp_c:        num(iaqi.t?.v),
              humidity:      num(iaqi.h?.v),
              pressure_hpa:  num(iaqi.p?.v),
              wind_speed_ms: toMS(num(iaqi.w?.v)),
              wind_gust_ms:  toMS(num(iaqi.wg?.v)),
            };

            const res = await fetch(`${POSTGREST_URL}/air_quality_current?on_conflict=station_id,ts`, {
              method: 'POST', headers, body: JSON.stringify([row])
            });
            const body = res.ok ? await res.json() : await res.text();
            console.log('air_quality_current upsert status:', res.status, 'rows_written:', Array.isArray(body) ? body.length : 0);
            if (!res.ok) { console.error('resp:', body); process.exit(1); }
          })().catch(e => { console.error(e); process.exit(1); });
          NODE







      - name: Fetch Torino traffic (5T XML) ‚Üí upsert api.traffic_flow_current
        env:
          POSTGREST_URL: ${{ secrets.POSTGREST_URL }}
          SERVICE_KEY:   ${{ secrets.SERVICE_KEY }}
          # ÿß⁄Øÿ± URL ÿπŸÖŸàŸÖ€å ÿØÿßÿ±€å:
          TRAFFIC_URL:   https://opendata.5t.torino.it/get_fdt
          # ÿß⁄Øÿ± URL ÿßÿÆÿ™ÿµÿßÿµ€å/ÿßŸÖÿ∂ÿßÿØÿßÿ± ÿØÿßÿ±€åÿå ÿ®Ÿá‚Äåÿ¨ÿß€å ÿÆÿ∑ ÿ®ÿßŸÑÿß:
          # TRAFFIC_URL:   ${{ secrets.TRAFFIC_URL }}
        run: |
          set -e
          npm init -y >/dev/null 2>&1
          npm install xml2js@0.6 >/dev/null 2>&1
          node - <<'NODE'
          const fetch = global.fetch;
          const { parseStringPromise } = require('xml2js');

          const POSTGREST_URL = process.env.POSTGREST_URL;
          const SERVICE_KEY   = process.env.SERVICE_KEY;
          const TRAFFIC_URL   = process.env.TRAFFIC_URL;

          const headers = {
            'apikey': SERVICE_KEY,
            'Authorization': `Bearer ${SERVICE_KEY}`,
            'Content-Type': 'application/json',
            'Prefer': 'resolution=merge-duplicates',
            'Content-Profile': 'api'
          };

          const num = x => {
            if (x === undefined || x === null) return null;
            const n = Number(x);
            return Number.isFinite(n) ? n : null;
          };

          function categorize(speed, flow, acc){
            if (acc === 0) return 'unknown';
            if (speed === 0 && flow > 0 && acc >= 50) return 'jam';
            if (speed === null) return 'unknown';
            if (speed >= 60) return 'free';
            if (speed >= 40) return 'moderate';
            if (speed >= 20) return 'busy';
            if (speed > 0)   return 'heavy';
            return 'unknown';
          }

          (async () => {
            const r = await fetch(TRAFFIC_URL, { headers: { 'Accept': 'application/xml,text/xml,*/*' } });
            if (!r.ok) { console.error('Traffic fetch failed', r.status, await r.text()); process.exit(1); }
            const xml = await r.text();

            // xml2js options: attributes ‚Üí $
            const j = await parseStringPromise(xml, {
              explicitArray: false,
              mergeAttrs: true,
              attrkey: '$',
              tagNameProcessors: [name => name.replace(/^[^:]*:/, '')] // ÿ≠ÿ∞ŸÅ namespace prefix
            });

            const root = j.traffic_data || j['traffic_data'];
            if (!root) { console.error('Unexpected XML root'); process.exit(1); }

            const window_start = root.start_time ? new Date(root.start_time).toISOString() : new Date().toISOString();
            const window_end   = root.end_time   ? new Date(root.end_time).toISOString()   : new Date().toISOString();
            const generation   = root.generation_time ? new Date(root.generation_time).toISOString() : null;

            let items = root.FDT_data || [];
            if (!Array.isArray(items)) items = [items];

            const rows = items.map(d => {
              const a  = d.$ || d;               // attributes
              const sf = d.speedflow?.$ || d.speedflow;

              const speed = num(sf?.speed);
              const flow  = num(sf?.flow);
              const acc   = num(a?.accuracy);

              return {
                lcd1:          String(a?.lcd1 ?? ''),
                road_lcd:      a?.Road_LCD ? String(a.Road_LCD) : null,
                road_name:     a?.Road_name || null,
                direction:     a?.direction || null,
                lat:           num(a?.lat),
                lon:           num(a?.lng),
                accuracy:      acc,
                period_min:    num(a?.period),

                // üî¥ ÿ¨ÿØ€åÿØ: offset_m Ÿàÿßÿ±ÿØ ÿ¥ŸàÿØ ÿ™ÿß PK ⁄©ÿßŸÖŸÑ ÿ¥ŸàÿØ
                offset_m:      a?.offset != null ? Number(a.offset) : 0,

                window_start:  window_start,
                window_end:    window_end,
                generation_time: generation,

                flow_vph:      flow,
                speed_kmh:     speed,

                congestion:    categorize(speed, flow, acc)
              };
            }).filter(r => r.lcd1 && r.direction);


            if (rows.length === 0) {
              console.log('traffic_flow_current: 204 payload_len: 0 (no rows)');
              return;
            }

            const resp = await fetch(`${POSTGREST_URL}/traffic_flow_current`, {
              method: 'POST', headers, body: JSON.stringify(rows)
            });
            const body = await resp.text();
            console.log('traffic_flow_current:', resp.status, 'rows:', rows.length, body || '<no-body>');
            if (!resp.ok) process.exit(1);
          })().catch(e => { console.error(e); process.exit(1); });
          NODE